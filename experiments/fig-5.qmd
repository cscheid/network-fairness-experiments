---
title: "Essential Worker Community Degree Distribution"
---

```{python}
import glob
from exps import *
import numpy
import matplotlib.pyplot as plt

def degrees(network):
    essential = list(len(l) for l in network[:1000])
    rest = list(len(l) for l in network[1000:])
    return [essential, rest]

essential = []
rest = []
files = glob.glob(f'../data/graphs/experiment_essential_workers_2_sbm/run_1/twocommunities_edgelist.txt')
for f in files:
    n = read_graph(f)
    [this_essential, this_rest] = degrees(n)
    essential.extend(this_essential)
    rest.extend(this_rest)
plt.figure()
hist(essential, label="Essential worker community")
hist(rest, label="Rest")
plt.legend()
plt.xlabel("Node degree")
plt.ylabel("Frequency")
plt.show()

def figure_1(params, xlabel):
    c1, c2 = split_result_by_communities(params["ic_result"], params)
    print("Community means: %s, %s" % (numpy.mean(c1), numpy.mean(c2)))
    hist(c1)
    hist(c2)
    plt.xlabel(xlabel)
    plt.ylabel("Frequency")

def delete_nodes_from_network(network, nodes_to_delete):
    network = read_graph(network)
    edge_list = graph_to_edge_list(network)
    for n in nodes_to_delete:
        network[n] = []
    network = list(list(e for e in l if e not in nodes_to_delete)
        for l in network)
    n = temp_name(".txt")
    write_graph(network, n)
    return n

```

## 1

```{python}
params = {}
degrees = numpy.array(list(len(n) for n in read_graph(files[0])))
params["thresholds"] = numpy.random.random(len(degrees)) * degrees
nodes_to_delete = set(set_seeds(dict(
                n1 = 1000,
                n2 = 1000,
                seed1 = 0.1,
                seed2 = 0.1)))
params["nodes_to_delete"] = nodes_to_delete
params["graph"] = delete_nodes_from_network(files[0], nodes_to_delete)
params["n1"] = 1000
params["n2"] = 1000
params["seed1"] = 0.1
params["seed2"] = 0.1
params["seeds"] = set_seeds(params)
params["alpha"] = 0.1
params["reprs"] = 100
params["communities"] = [list(range(0, 1000)), list(range(1000, 2000))]
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 2

```{python}
params["ic_result"] = run_thresh_experiment(params)

plt.figure()
figure_1(params, "collateral harm")
plt.show()
```

## 3a, SBM-based

```{python}
params = {}
params["thresholds"] = numpy.random.random(len(degrees)) * degrees
nodes_to_delete = set(set_seeds(dict(
                n1 = 1000,
                n2 = 1000,
                seed1 = 0.12,
                seed2 = 0.08)))
params["nodes_to_delete"] = nodes_to_delete
params["graph"] = files[0]
params["n1"] = 1000
params["n2"] = 1000
params["seed1"] = 0.1
params["seed2"] = 0.1
params["seeds"] = set_seeds(params)
params["alpha"] = 0.1
params["reprs"] = 100
params["communities"] = [list(range(0, 1000)), list(range(1000, 2000))]
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 3b, degree-based

```{python}
probs = numpy.array(degrees)
probs = (probs / probs.sum()) * 200.0
nodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)
params["nodes_to_delete"] = nodes_to_delete
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 3c, probability-based

```{python}
probs = numpy.array(degrees)
probs = 1 - numpy.power(1 - params["alpha"], degrees)
probs = (probs / probs.sum()) * 200.0
nodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)
params["nodes_to_delete"] = nodes_to_delete
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 4

```{python}
params["ic_result"] = run_thresh_experiment(params)

plt.figure()
figure_1(params, "collateral harm")
plt.show()
```

# multiple non-essential communities

With this, we attempt to keep average degrees consistent across the
experiments, but now there are _four_ non-essential worker
communities, and one essential worker community. The community sizes
are 400 each.

## 1

```{python}
many_comms = community_graph(
    0.0001/2,
    int(1000 * 0.4), (0.015 / 2) / 0.4,
    int(1000 * 0.4), (0.01 / 2) / 0.4,
    int(1000 * 0.4), (0.01 / 2) / 0.4,
    int(1000 * 0.4), (0.01 / 2) / 0.4,
    int(1000 * 0.4), (0.01 / 2) / 0.4)

nodes_to_delete = set(set_seeds(dict(
                n1 = 400,
                n2 = 1600,
                seed1 = 0.1,
                seed2 = 0.1)))
params["nodes_to_delete"] = nodes_to_delete
params["graph"] = delete_nodes_from_network(many_comms, nodes_to_delete)
params["n1"] = 400
params["n2"] = 1600
params["seed1"] = 0.1
params["seed2"] = 0.1
params["seeds"] = set_seeds(params)
params["alpha"] = 0.1
params["reprs"] = 100
params["communities"] = [list(range(0, 400)), list(range(400, 2000))]
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 2

```{python}
params["ic_result"] = run_thresh_experiment(params)

plt.figure()
figure_1(params, "collateral harm")
plt.show()
```

## 3a, SBM-based

This is not exactly comparable because since the overall sizes changed, there are
now fewer essential workers, so to make vaccination rate difference match the
degree difference, we need to change the parameters.

We arrive at $s_1$, $s_2$ by solving the system $s_1 = s_2 \times 1.5$, $400 s_1 + 1600 s_2 = 200$.

```{python}
params = {}
params["thresholds"] = numpy.random.random(len(degrees)) * degrees
nodes_to_delete = set(set_seeds(dict(
                n1 = 400,
                n2 = 1600,
                seed1 = (200 / 2200) * 1.5,
                seed2 = 200 / 2200)))
params["nodes_to_delete"] = nodes_to_delete
params["graph"] = files[0]
params["n1"] = 1000
params["n2"] = 1000
params["seed1"] = 0.1
params["seed2"] = 0.1
params["seeds"] = set_seeds(params)
params["alpha"] = 0.1
params["reprs"] = 100
params["communities"] = [list(range(0, 1000)), list(range(1000, 2000))]
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 3b, degree-based

```{python}
probs = numpy.array(degrees)
probs = (probs / probs.sum()) * 200.0
nodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)
params["nodes_to_delete"] = nodes_to_delete
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 3c, probability-based

```{python}
probs = numpy.array(degrees)
probs = 1 - numpy.power(1 - params["alpha"], degrees)
probs = (probs / probs.sum()) * 200.0
nodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)
params["nodes_to_delete"] = nodes_to_delete
params["ic_result"] = run_experiment(params)

plt.figure()
figure_1(params, "probability of infection")
plt.show()
```

## 4

```{python}
params["ic_result"] = run_thresh_experiment(params)

plt.figure()
figure_1(params, "collateral harm")
plt.show()
```
