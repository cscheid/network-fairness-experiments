[
  {
    "objectID": "index.html#todo",
    "href": "index.html#todo",
    "title": "Network fairness experiments",
    "section": "TODO",
    "text": "TODO\n\nCollateral consequences: run ic with n=1 instead of n=10000, and change min and mean to run ic inside of them instead of taking a result\n\nin addition to the “default” aggregation, also allow each node to get a random univariate [0,1] that scales the value before the aggregation\n\nMake fairness graphs for each experiment\nExperiment 1+2:\n\nremove nodes based on mean of IC calculations (experiment 1)\nthen seed equally across communities\nmeasure disparity/access\nplot degree distribution\n\nExperiment “3”: equitable vaccine distribution\n\nspecific graph: 12 communities, 1 is essential worker community; SBM described on the paper\nfairness calculation is essential workers over non-essential workers\nequal vaccination rate, look at resulting distributions\n\nmeasure direct harm\nmeasure collateral consequences\n\nvaccinate proportionally to degree distribution <- this is a proxy for direct harm\n\nmeasure direct harm\nmeasure collateral consequences\n\nvaccinate proportionally to “purely network-centric collateral consequences” <- what is the proxy for collateral consequence?\n\nmeasure direct harm\nmeasure collateral consequences\n\n\nGraphs (each repeated n times):\n\nSBM\nLFR\nSBM “more connected”\nLFR “more connected”\nEssential worker community\n\nCarlos works with Jade and Nasanbayar to make sure everyone can run things everywhere.\n\nGet graph files in the repo.\nGet Nasanbayar and Jade up and running with quarto."
  },
  {
    "objectID": "exp1+2.html",
    "href": "exp1+2.html",
    "title": "",
    "section": "",
    "text": "Code\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\ndef graph_to_edge_list(network):\n    result = []\n    for (node_id, neighbors) in enumerate(network):\n        for neighbor in neighbors:\n            result.append([node_id, neighbor])\n    return result\n    \ndef write_output(G, filename):\n    with open(filename, 'w') as txt_file:\n        num_of_nodes = len(G.nodes)\n        directed = 0\n        txt_file.write(\"{}\\t{}\\n\".format(num_of_nodes, directed))\n        for edge in G.edges:\n            txt_file.write(\"{}\\t{}\\n\".format(edge[0], edge[1]))\n    \ndef delete_nodes_from_network(network):\n    network = read_graph(network)\n    edge_list = graph_to_edge_list(network)\n    nodes_to_delete = set() # solve_this_later()\n    # NB we're deleting all edges instead of the nodes so that\n    # the communities stay the same\n    #for i in range(1000):\n    #    r = random.random()\n    #    if r < 0.1:\n    #        nodes_to_delete.add(i)\n    #for i in range(1000, 2000):\n    #    r = random.random()\n    #    if r < 0.3:\n    #        nodes_to_delete.add(i)\n    edge_list = list(\n        edge for edge in edge_list\n        if (edge[0] not in nodes_to_delete and\n            edge[1] not in nodes_to_delete))\n    g = nx.Graph(edge_list)\n    write_output(g, \"output.txt\")\n    return \"output.txt\"\n    \ndef make_params(shrink_factor):\n    return dict(\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(network, communities, factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"n\"] = 1000\n        params[\"n1\"] = 1000\n        params[\"n2\"] = 1000\n        params[\"graph\"] = delete_nodes_from_network(network)\n        params[\"communities\"] = communities\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    def mean_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.mean(v)\n    return list(mean_or_none(v) for v in r)\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    def min_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.min(v)\n    return list(min_or_none(v) for v in r)\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(network, community, f, label):\n    c1s, c2s = run_experiment_range(network, community, factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\n# Note, we'll have to fix the community calculate to create the right communities when\n# using the different graphs\ncommunities = [list(range(1000)), list(range(1000, 2000))]\nnetwork = \"../data/reference_communities/Isolated_communities/SBM/Run_1/twocommunities_edgelist.txt\"\nplot_curve(\n    network,\n    communities,\n    id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(\n    network,\n    communities,\n    square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(\n    network,\n    communities,\n    mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(\n    network,\n    communities,\n    min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\nTitle: \"Experiment 1+2\"\nformat:\n  html:\n    code-tools: true\n    code-fold: true\n---\n\n#\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n\ndef graph_to_edge_list(network):\n    result = []\n    for (node_id, neighbors) in enumerate(network):\n        for neighbor in neighbors:\n            result.append([node_id, neighbor])\n    return result\n    \ndef write_output(G, filename):\n    with open(filename, 'w') as txt_file:\n        num_of_nodes = len(G.nodes)\n        directed = 0\n        txt_file.write(\"{}\\t{}\\n\".format(num_of_nodes, directed))\n        for edge in G.edges:\n            txt_file.write(\"{}\\t{}\\n\".format(edge[0], edge[1]))\n    \ndef delete_nodes_from_network(network):\n    network = read_graph(network)\n    edge_list = graph_to_edge_list(network)\n    nodes_to_delete = set() # solve_this_later()\n    # NB we're deleting all edges instead of the nodes so that\n    # the communities stay the same\n    #for i in range(1000):\n    #    r = random.random()\n    #    if r < 0.1:\n    #        nodes_to_delete.add(i)\n    #for i in range(1000, 2000):\n    #    r = random.random()\n    #    if r < 0.3:\n    #        nodes_to_delete.add(i)\n    edge_list = list(\n        edge for edge in edge_list\n        if (edge[0] not in nodes_to_delete and\n            edge[1] not in nodes_to_delete))\n    g = nx.Graph(edge_list)\n    write_output(g, \"output.txt\")\n    return \"output.txt\"\n    \ndef make_params(shrink_factor):\n    return dict(\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(network, communities, factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"n\"] = 1000\n        params[\"n1\"] = 1000\n        params[\"n2\"] = 1000\n        params[\"graph\"] = delete_nodes_from_network(network)\n        params[\"communities\"] = communities\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    def mean_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.mean(v)\n    return list(mean_or_none(v) for v in r)\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    def min_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.min(v)\n    return list(min_or_none(v) for v in r)\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(network, community, f, label):\n    c1s, c2s = run_experiment_range(network, community, factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\n```\n\nNo transformation:\n\n```{python}\n# Note, we'll have to fix the community calculate to create the right communities when\n# using the different graphs\ncommunities = [list(range(1000)), list(range(1000, 2000))]\nnetwork = \"../data/reference_communities/Isolated_communities/SBM/Run_1/twocommunities_edgelist.txt\"\nplot_curve(\n    network,\n    communities,\n    id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(\n    network,\n    communities,\n    square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(\n    network,\n    communities,\n    mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(\n    network,\n    communities,\n    min, \"min of neighbors' prob\")\n```"
  },
  {
    "objectID": "exp1.html",
    "href": "exp1.html",
    "title": "Experiment 1",
    "section": "",
    "text": "Two Erdos-Renyi graphs \\(n=1000, p=0.01\\) connected to one another with random edges, \\(p=0.0001\\). We overseed one community and look at the access probabilities.\n(I’m dividing the probability by 2 there so that my results match those of the students. I’m pretty sure this is harmless and coming from different convention on how to interpret the values in symmetric graphs when generating them, etc.)\n\nCode\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))]\n    )\n\nWe generate a community graph and seeds:\n\nCode\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n\nThen, we run the IC computation:\n\nCode\nic_result = run_experiment(params)\n\nFinally, we plot the distribution of access probabilities across the communities:\n\nBasic\nAccess probs:\n\n\n\n\n\n\\(x^2\\) access probs:\nAccess probs:\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 1\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nTwo Erdos-Renyi graphs $n=1000, p=0.01$ connected to one another with random edges, $p=0.0001$.\nWe overseed one community and look at the access probabilities.\n\n(I'm dividing the probability by 2 there so that my results match\nthose of the students. I'm pretty sure this is harmless and coming\nfrom different convention on how to interpret the values in symmetric\ngraphs when generating them, etc.)\n\n```{python}\n#| code-fold: show\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))]\n    )\n    \n```\n\nWe generate a community graph and seeds:\n\n```{python}\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n```\n\nThen, we run the IC computation:\n\n```{python}\nic_result = run_experiment(params)\n```\n\nFinally, we plot the distribution of access probabilities across the\ncommunities:\n\n# Basic\n\nAccess probs:\n```{python}\n#| echo: false\nplt.figure()\nplot_community_dists(ic_result, params)\nplt.show()\n```\n\n$x^2$ access probs:\n\nAccess probs:\n```{python}\n#| echo: false\nplt.figure()\nplot_community_dists(list(v ** 2 for v in ic_result), params)\nplt.show()\n```"
  },
  {
    "objectID": "exp2.html",
    "href": "exp2.html",
    "title": "Experiment 2",
    "section": "",
    "text": "Same graph as experiment 1, but we now measure the “collateral” consequences in a few different ways.\n\nCode\nfrom exps import *\nimport numpy\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))])\n\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n\nWe generate a community graph, seeds, run the IC computation as before.\n\nCode\nic_result = run_experiment(params)\n\nBut now we collect our neighbor’s information first, and then compute the mean over that:\n\n\nCode\nimport matplotlib.pyplot as plt\n\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.mean(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n\n\n\n\n\nOr the min:\n\n\nCode\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.min(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 2\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nSame graph as [experiment 1](exp1.html), but we now measure the\n\"collateral\" consequences in a few different ways.\n\n```{python}\n#| code-fold: show\nfrom exps import *\nimport numpy\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))])\n\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n```\n\nWe generate a community graph, seeds, run the IC computation as before.\n\n```{python}\nic_result = run_experiment(params)\n```\n\nBut now we collect our neighbor's information first, and then compute the mean over that:\n\n```{python}\nimport matplotlib.pyplot as plt\n\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.mean(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n```\n\nOr the min:\n\n```{python}\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.min(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n```"
  },
  {
    "objectID": "exp3.html",
    "href": "exp3.html",
    "title": "Experiment 3",
    "section": "",
    "text": "Two Erdos-Renyi graphs \\(n=1000, p=0.01\\) connected to one another with random edges, \\(p=0.0001\\). Same as before, but now we look at the overall probability conditioned on the community, and vary the overseeding.\n\nCode\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport json\n\ndef make_params(overseeding_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = overseeding_factor * 0.1,\n        seed2 = 0.1,\n        # IC params\n        alpha = 0.1,\n        reprs = 100,\n        communities = [list(range(0, 1000)), list(range(1000, 2000))]\n        )\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    def mean_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.mean(v)\n    return list(mean_or_none(v) for v in r)\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    def min_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.min(v)\n    return list(min_or_none(v) for v in r)\n\nfactors = [1,2,3,4,5,6,7,8,9]\n\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Overseeding factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 3\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nTwo Erdos-Renyi graphs $n=1000, p=0.01$ connected to one another with random edges, $p=0.0001$.\nSame as before, but now we look at the overall probability conditioned on the community, and\nvary the overseeding.\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport json\n\ndef make_params(overseeding_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = overseeding_factor * 0.1,\n        seed2 = 0.1,\n        # IC params\n        alpha = 0.1,\n        reprs = 100,\n        communities = [list(range(0, 1000)), list(range(1000, 2000))]\n        )\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    def mean_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.mean(v)\n    return list(mean_or_none(v) for v in r)\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    def min_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.min(v)\n    return list(min_or_none(v) for v in r)\n\nfactors = [1,2,3,4,5,6,7,8,9]\n\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Overseeding factor\")\n    plt.ylabel(label)\n    plt.show()\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(min, \"min of neighbors' prob\")\n```"
  },
  {
    "objectID": "exp4.html",
    "href": "exp4.html",
    "title": "",
    "section": "",
    "text": "Community-wide impact of network modifications\n(This is Section 5.3)\nSame as experiment 3, but we range the community shrinkage from 0.1 to 0.9.\n\nCode\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        params[\"communities\"] = [list(range(0, n1)), list(range(n1, n1 + n2))]\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n    \ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    def mean_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.mean(v)\n    return list(mean_or_none(v) for v in r)\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    def min_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.min(v)\n    return list(min_or_none(v) for v in r)\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\nTitle: \"Experiment 4\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\n# Community-wide impact of network modifications\n\n(This is Section 5.3)\n\nSame as [experiment 3](exp3.qmd), but we range the community shrinkage from 0.1 to 0.9.\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        params[\"communities\"] = [list(range(0, n1)), list(range(n1, n1 + n2))]\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n    \ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    def mean_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.mean(v)\n    return list(mean_or_none(v) for v in r)\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    def min_or_none(v):\n        if len(v) == 0:\n            return None\n        return numpy.min(v)\n    return list(min_or_none(v) for v in r)\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(min, \"min of neighbors' prob\")\n```"
  }
]