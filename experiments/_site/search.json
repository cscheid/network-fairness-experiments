[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Network fairness experiments",
    "section": "",
    "text": "Reports:\n\nExperiment 1: some overseeding, collateral dmg as “square”\nExperiment 2: some overseeding, collateral dmg as average or min over neighbors\nExperiment 3: (5.2) vary overseeding, look also at collateral dmg\nExperiment 4: (5.3) vary node removal, look also at collateral dmg\n\nSupporting files:\n\nutils.py\nexps.py\n\n\n\n\nSource Code\n---\ntitle: \"Network fairness experiments\"\nformat: html\n---\n\nReports:\n\n* [Experiment 1](exp1.qmd): some overseeding, collateral dmg as \"square\"\n* [Experiment 2](exp2.qmd): some overseeding, collateral dmg as average or min over neighbors\n* [Experiment 3](exp3.qmd): (5.2) vary overseeding, look also at collateral dmg\n* [Experiment 4](exp4.qmd): (5.3) vary node removal, look also at collateral dmg\n\nSupporting files:\n\n* [utils.py](utils.py)\n* [exps.py](exps.py)"
  },
  {
    "objectID": "exp1.html",
    "href": "exp1.html",
    "title": "Experiment 1",
    "section": "",
    "text": "Two Erdos-Renyi graphs \\(n=1000, p=0.01\\) connected to one another with random edges, \\(p=0.0001\\). We overseed one community and look at the access probabilities:\n\nCode\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000)\n\ngraph = two_communities(params)\nseeds = set_seeds(params)\n\nWe generate a community graph, seeds, run the IC computation, and plot the distribution of access probabilities across the two communities:\n\nCode\nparams[\"graph\"] = graph\nparams[\"seeds\"] = seeds\n\nic_result = run_experiment(params)\n\n\nBasic\nAccess probs:\n\n\n\n\n\n\\(x^2\\) access probs:\nAccess probs:\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 1\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nTwo Erdos-Renyi graphs $n=1000, p=0.01$ connected to one another with random edges, $p=0.0001$.\nWe overseed one community and look at the access probabilities:\n\n```{python}\n#| code-fold: show\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000)\n\ngraph = two_communities(params)\nseeds = set_seeds(params)\n```\n\nWe generate a community graph, seeds, run the IC computation, and plot the distribution of access probabilities across\nthe two communities:\n\n```{python}\nparams[\"graph\"] = graph\nparams[\"seeds\"] = seeds\n\nic_result = run_experiment(params)\n\n```\n\n# Basic\n\nAccess probs:\n```{python}\n#| echo: false\nplt.figure()\nplot_community_dists(ic_result, params)\nplt.show()\n```\n\n$x^2$ access probs:\n\nAccess probs:\n```{python}\n#| echo: false\nplt.figure()\nplot_community_dists(list(v ** 2 for v in ic_result), params)\nplt.show()\n```"
  },
  {
    "objectID": "exp2.html",
    "href": "exp2.html",
    "title": "Experiment 2",
    "section": "",
    "text": "Same graph as experiment 1, but we now measure the “collateral” consequences in a few different ways.\n\nCode\nfrom exps import *\nimport numpy\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000)\n\ngraph = two_communities(params)\nseeds = set_seeds(params)\n\nWe generate a community graph, seeds, run the IC computation as before.\n\nCode\nparams[\"graph\"] = graph\nparams[\"seeds\"] = seeds\n\nic_result = run_experiment(params)\n\nBut now we collect our neighbor’s information first, and then compute the mean over that:\n\n\nCode\nimport matplotlib.pyplot as plt\n\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.mean(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n\n\n\n\n\nOr the min:\n\n\nCode\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.min(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 2\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nSame graph as [experiment 1](exp1.html), but we now measure the\n\"collateral\" consequences in a few different ways.\n\n```{python}\n#| code-fold: show\nfrom exps import *\nimport numpy\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000)\n\ngraph = two_communities(params)\nseeds = set_seeds(params)\n```\n\nWe generate a community graph, seeds, run the IC computation as before.\n\n```{python}\nparams[\"graph\"] = graph\nparams[\"seeds\"] = seeds\n\nic_result = run_experiment(params)\n```\n\nBut now we collect our neighbor's information first, and then compute the mean over that:\n\n```{python}\nimport matplotlib.pyplot as plt\n\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.mean(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n```\n\nOr the min:\n\n```{python}\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.min(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n```"
  },
  {
    "objectID": "exp3.html",
    "href": "exp3.html",
    "title": "Experiment 3",
    "section": "",
    "text": "Two Erdos-Renyi graphs \\(n=1000, p=0.01\\) connected to one another with random edges, \\(p=0.0001\\). Same as before, but now we look at the overall probability conditioned on the community, and vary the overseeding.\n\nCode\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(overseeding_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = overseeding_factor * 0.1,\n        seed2 = 0.1,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        graph = two_communities(params)\n        seeds = set_seeds(params)\n        params[\"graph\"] = graph\n        params[\"seeds\"] = seeds\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.mean(v) for v in r if len(v))\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.min(v) for v in r if len(v))\n\nfactors = [1,2,3,4,5,6,7,8,9]\n\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Overseeding factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 3\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nTwo Erdos-Renyi graphs $n=1000, p=0.01$ connected to one another with random edges, $p=0.0001$.\nSame as before, but now we look at the overall probability conditioned on the community, and\nvary the overseeding.\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(overseeding_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = overseeding_factor * 0.1,\n        seed2 = 0.1,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        graph = two_communities(params)\n        seeds = set_seeds(params)\n        params[\"graph\"] = graph\n        params[\"seeds\"] = seeds\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.mean(v) for v in r if len(v))\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.min(v) for v in r if len(v))\n\nfactors = [1,2,3,4,5,6,7,8,9]\n\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Overseeding factor\")\n    plt.ylabel(label)\n    plt.show()\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(min, \"min of neighbors' prob\")\n```"
  },
  {
    "objectID": "exp4.html",
    "href": "exp4.html",
    "title": "",
    "section": "",
    "text": "Community-wide impact of network modifications\n(This is Section 5.3)\nSame as experiment 3, but we range the community shrinkage from 0.1 to 0.9.\n\nCode\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        graph = two_communities(params)\n        seeds = set_seeds(params)\n        params[\"graph\"] = graph\n        params[\"seeds\"] = seeds\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n    \ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.mean(v) for v in r if len(v))\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.min(v) for v in r if len(v))\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\nTitle: \"Experiment 4\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\n# Community-wide impact of network modifications\n\n(This is Section 5.3)\n\nSame as [experiment 3](experiment3.qmd), but we range the community shrinkage from 0.1 to 0.9.\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        graph = two_communities(params)\n        seeds = set_seeds(params)\n        params[\"graph\"] = graph\n        params[\"seeds\"] = seeds\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n    \ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.mean(v) for v in r if len(v))\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.min(v) for v in r if len(v))\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(min, \"min of neighbors' prob\")\n```"
  },
  {
    "objectID": "exp1+2.html",
    "href": "exp1+2.html",
    "title": "",
    "section": "",
    "text": "Code\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        ##\n        network = \"../data/reference_communities/Isolated_communities/SBM/Run_1\",\n        ##\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        graph = two_communities(params)\n        seeds = set_seeds(params)\n        params[\"graph\"] = graph\n        params[\"seeds\"] = seeds\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.mean(v) for v in r if len(v))\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.min(v) for v in r if len(v))\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(mean, \"mean of neighbors' prob\")\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3440: RuntimeWarning: Mean of empty slice.\n  return _methods._mean(a, axis=axis, dtype=dtype,\n/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/numpy/core/_methods.py:189: RuntimeWarning: invalid value encountered in double_scalars\n  ret = ret.dtype.type(ret / rcount)\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(min, \"min of neighbors' prob\")\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\nTraceback (most recent call last):\n  File \"../retrieve_community_graph.py\", line 39, in <module>\n    i, j = int(line[0]), int(line[1])\nValueError: invalid literal for int() with base 10: ''\n\n\n\n\n\n\n\n\nSource Code\n---\nTitle: \"Experiment 1+2\"\nformat:\n  html:\n    code-tools: true\n    code-fold: true\n---\n\n#\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        ##\n        network = \"../data/reference_communities/Isolated_communities/SBM/Run_1\",\n        ##\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        graph = two_communities(params)\n        seeds = set_seeds(params)\n        params[\"graph\"] = graph\n        params[\"seeds\"] = seeds\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\ndef id(r, params):\n    return r\ndef square(r, params):\n    return numpy.array(r) ** 2\ndef mean(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.mean(v) for v in r if len(v))\ndef min(r, params):\n    r = collect_neighbor_data(r, params)\n    return list(numpy.min(v) for v in r if len(v))\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(min, \"min of neighbors' prob\")\n```"
  }
]