[
  {
    "objectID": "collateral.html",
    "href": "collateral.html",
    "title": "Collateral Consequences",
    "section": "",
    "text": "Jensen’s inequality stuff\nHere we aggregate last\n\nCode\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))]\n    )\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n\nic_neighbor_result_mean = read_array(ic_fun(\n    params[\"graph\"],\n    array_into_file(params[\"seeds\"]),\n    str(params[\"alpha\"]),\n    str(params[\"reprs\"]),\n    \"mean\"\n    ))\n\nic_neighbor_result_min = read_array(ic_fun(\n    params[\"graph\"],\n    array_into_file(params[\"seeds\"]),\n    str(params[\"alpha\"]),\n    str(params[\"reprs\"]),\n    \"min\"\n    ))\n\nMean shouldn’t change:\n\n\nCode\nplot_community_dists(ic_neighbor_result_mean, params)\n\n\n\n\n\nMin should change:\n\n\nCode\nplot_community_dists(ic_neighbor_result_mean, params)\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Collateral Consequences\"\n---\n\n# Jensen's inequality stuff\n\nHere we aggregate last\n\n```{python}\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))]\n    )\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n\nic_neighbor_result_mean = read_array(ic_fun(\n    params[\"graph\"],\n    array_into_file(params[\"seeds\"]),\n    str(params[\"alpha\"]),\n    str(params[\"reprs\"]),\n    \"mean\"\n    ))\n\nic_neighbor_result_min = read_array(ic_fun(\n    params[\"graph\"],\n    array_into_file(params[\"seeds\"]),\n    str(params[\"alpha\"]),\n    str(params[\"reprs\"]),\n    \"min\"\n    ))\n```\n\nMean shouldn't change:\n\n```{python}\nplot_community_dists(ic_neighbor_result_mean, params)\n\n```\n\nMin should change:\n\n```{python}\nplot_community_dists(ic_neighbor_result_mean, params)\n\n```"
  },
  {
    "objectID": "index.html#files-with-figures",
    "href": "index.html#files-with-figures",
    "title": "Network fairness experiments",
    "section": "Files with figures",
    "text": "Files with figures\n\nfig 2\nfig 5"
  },
  {
    "objectID": "index.html#thresholds",
    "href": "index.html#thresholds",
    "title": "Network fairness experiments",
    "section": "Thresholds",
    "text": "Thresholds"
  },
  {
    "objectID": "index.html#collateral-consequences",
    "href": "index.html#collateral-consequences",
    "title": "Network fairness experiments",
    "section": "Collateral Consequences",
    "text": "Collateral Consequences\n\ncollateral consequences experiments."
  },
  {
    "objectID": "exp1+2.html#collateral-consequences-functions",
    "href": "exp1+2.html#collateral-consequences-functions",
    "title": "",
    "section": "Collateral consequences functions",
    "text": "Collateral consequences functions\nNote, we’ll have to fix the community calculate to create the right communities when using the different graphs. Right now we’re using a specific network for which we know the community configuration.\nNo transformation:\n\n\nCode\ncommunities = [list(range(1000)), list(range(1000, 2000))]\nnetwork = \"../data/reference_communities/Isolated_communities/SBM/run_1/twocommunities_edgelist.txt\"\nplot_curve(\n    network,\n    communities,\n    id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(\n    network,\n    communities,\n    square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(\n    network,\n    communities,\n    f_mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(\n    network,\n    communities,\n    f_min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\nTitle: \"Experiment 1+2\"\nformat:\n  html:\n    code-tools: true\n    code-fold: true\n---\n\n#\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport random\n   \ndef delete_nodes_from_network(network):\n    network = read_graph(network)\n    edge_list = graph_to_edge_list(network)\n    nodes_to_delete = set() # solve_this_later()\n    # NB we're deleting all edges instead of the nodes so that\n    # the communities stay the same\n    #for i in range(1000):\n    #    r = random.random()\n    #    if r < 0.1:\n    #        nodes_to_delete.add(i)\n    #for i in range(1000, 2000):\n    #    r = random.random()\n    #    if r < 0.3:\n    #        nodes_to_delete.add(i)\n    edge_list = list(\n        edge for edge in edge_list\n        if (edge[0] not in nodes_to_delete and\n            edge[1] not in nodes_to_delete))\n    g = nx.Graph(edge_list)\n    write_output(g, \"output.txt\")\n    return \"output.txt\"\n    \ndef make_params(shrink_factor):\n    return dict(\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(network, communities, factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"n\"] = 1000\n        params[\"n1\"] = 1000\n        params[\"n2\"] = 1000\n        params[\"graph\"] = delete_nodes_from_network(network)\n        params[\"communities\"] = communities\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(network, community, f, label):\n    c1s, c2s = run_experiment_range(network, community, factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\n```\n\n## Collateral consequences functions\n\nNote, we'll have to fix the community calculate to create the right\ncommunities when using the different graphs. Right now we're using\na specific network for which we know the community configuration.\n\nNo transformation:\n\n```{python}\ncommunities = [list(range(1000)), list(range(1000, 2000))]\nnetwork = \"../data/reference_communities/Isolated_communities/SBM/run_1/twocommunities_edgelist.txt\"\nplot_curve(\n    network,\n    communities,\n    id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(\n    network,\n    communities,\n    square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(\n    network,\n    communities,\n    f_mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(\n    network,\n    communities,\n    f_min, \"min of neighbors' prob\")\n```"
  },
  {
    "objectID": "exp1.html",
    "href": "exp1.html",
    "title": "Experiment 1",
    "section": "",
    "text": "Two Erdos-Renyi graphs \\(n=1000, p=0.01\\) connected to one another with random edges, \\(p=0.0001\\). We overseed one community and look at the access probabilities.\n(I’m dividing the probability by 2 there so that my results match those of the students. I’m pretty sure this is harmless and coming from different convention on how to interpret the values in symmetric graphs when generating them, etc.)\n\nCode\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))]\n    )\n\nWe generate a community graph and seeds:\n\nCode\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n\nThen, we run the IC computation:\n\nCode\nic_result = run_experiment(params)\n\nFinally, we plot the distribution of access probabilities across the communities:\n\nBasic\nAccess probs:\n\n\n\n\n\n\\(x^2\\) access probs:\nAccess probs:\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 1\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nTwo Erdos-Renyi graphs $n=1000, p=0.01$ connected to one another with random edges, $p=0.0001$.\nWe overseed one community and look at the access probabilities.\n\n(I'm dividing the probability by 2 there so that my results match\nthose of the students. I'm pretty sure this is harmless and coming\nfrom different convention on how to interpret the values in symmetric\ngraphs when generating them, etc.)\n\n```{python}\n#| code-fold: show\nfrom exps import *\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))]\n    )\n    \n```\n\nWe generate a community graph and seeds:\n\n```{python}\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n```\n\nThen, we run the IC computation:\n\n```{python}\nic_result = run_experiment(params)\n```\n\nFinally, we plot the distribution of access probabilities across the\ncommunities:\n\n# Basic\n\nAccess probs:\n```{python}\n#| echo: false\nplt.figure()\nplot_community_dists(ic_result, params)\nplt.show()\n```\n\n$x^2$ access probs:\n\nAccess probs:\n```{python}\n#| echo: false\nplt.figure()\nplot_community_dists(list(v ** 2 for v in ic_result), params)\nplt.show()\n```"
  },
  {
    "objectID": "fig-2.html",
    "href": "fig-2.html",
    "title": "Getting Figure 2 from the paper",
    "section": "",
    "text": "Code\nimport glob\nfrom exps import *\nimport matplotlib.pyplot as plt\n\nmodel = [\"SBM\", \"LFR\"]\ndr = { \"SBM\": (0, 40), \"LFR\": (0, 60) }\ncommunities = [\"Isolated_communities\", \"More_connected_communities\"]\n\ndef degrees(network):\n    return list(len(l) for l in network)\n\nfor m in model:\n    for c in communities:\n        files = glob.glob(f'../data/reference_communities/{c}/{m}/Run_*/twocommunities_edgelist.txt')\n        l = []\n        for f in files:\n            n = read_graph(f)\n            degs = degrees(n)\n            l.extend(degs)\n        print(l)\n        plt.figure()\n        hist(l, range=dr[m])\n        plt.title(f'{m}, {c}')\n        plt.xlabel(\"Node degree\")\n        plt.ylabel(\"Frequency\")\n        plt.show()\n\n\n[]\n\n\n/Users/cscheid/virtualenvs/venv_39/lib/python3.9/site-packages/numpy/lib/histograms.py:906: RuntimeWarning:\n\ninvalid value encountered in true_divide\n\n\n\n\n\n\n[]\n\n\n/Users/cscheid/virtualenvs/venv_39/lib/python3.9/site-packages/numpy/lib/histograms.py:906: RuntimeWarning:\n\ninvalid value encountered in true_divide\n\n\n\n\n\n\n[]\n\n\n/Users/cscheid/virtualenvs/venv_39/lib/python3.9/site-packages/numpy/lib/histograms.py:906: RuntimeWarning:\n\ninvalid value encountered in true_divide\n\n\n\n\n\n\n[]\n\n\n/Users/cscheid/virtualenvs/venv_39/lib/python3.9/site-packages/numpy/lib/histograms.py:906: RuntimeWarning:\n\ninvalid value encountered in true_divide\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Getting Figure 2 from the paper\"\n---\n\n```{python}\nimport glob\nfrom exps import *\nimport matplotlib.pyplot as plt\n\nmodel = [\"SBM\", \"LFR\"]\ndr = { \"SBM\": (0, 40), \"LFR\": (0, 60) }\ncommunities = [\"Isolated_communities\", \"More_connected_communities\"]\n\ndef degrees(network):\n    return list(len(l) for l in network)\n\nfor m in model:\n    for c in communities:\n        files = glob.glob(f'../data/reference_communities/{c}/{m}/Run_*/twocommunities_edgelist.txt')\n        l = []\n        for f in files:\n            n = read_graph(f)\n            degs = degrees(n)\n            l.extend(degs)\n        print(l)\n        plt.figure()\n        hist(l, range=dr[m])\n        plt.title(f'{m}, {c}')\n        plt.xlabel(\"Node degree\")\n        plt.ylabel(\"Frequency\")\n        plt.show()\n```"
  },
  {
    "objectID": "thresholds.html",
    "href": "thresholds.html",
    "title": "Threshold tests",
    "section": "",
    "text": "Code\nfrom exps import *\nimport numpy\nimport seaborn as sns\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))])\n\ndef make_thresholds(params):\n    n = read_graph(params[\"graph\"])\n    degrees = numpy.array(list(len(e) for e in n))\n    return \n\nparams[\"graph\"] = two_communities(params)\ndegrees = numpy.array(list(len(n) for n in read_graph(params[\"graph\"])))\nparams[\"seeds\"] = set_seeds(params)\nparams[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\n\nresult = numpy.array(run_thresh_experiment(params))\n\nnonseeds = numpy.array([True] * 2000)\nnonseeds[params[\"seeds\"]] = False\nnorm_thresh = params[\"thresholds\"] / degrees\n\n(Communities encoded with colors)\n\n\nCode\nplt.figure()\nsns.scatterplot(\n    x = norm_thresh[:1000][nonseeds[:1000]],\n    y = result[:1000][nonseeds[:1000]])\nsns.scatterplot(\n    x = norm_thresh[1000:][nonseeds[1000:]],\n    y = result[1000:][nonseeds[1000:]])\nplt.xlabel(\"Threshold\")\nplt.ylabel(\"Average activation\")\nplt.show()\n\nplt.figure()\nhist(result[:1000][nonseeds[:1000]])\nhist(result[1000:][nonseeds[1000:]])\nplt.xlabel(\"Threshold\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Threshold tests\"\n---\n\n```{python}\n#| code-fold: show\nfrom exps import *\nimport numpy\nimport seaborn as sns\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))])\n\ndef make_thresholds(params):\n    n = read_graph(params[\"graph\"])\n    degrees = numpy.array(list(len(e) for e in n))\n    return \n\nparams[\"graph\"] = two_communities(params)\ndegrees = numpy.array(list(len(n) for n in read_graph(params[\"graph\"])))\nparams[\"seeds\"] = set_seeds(params)\nparams[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\n\nresult = numpy.array(run_thresh_experiment(params))\n\nnonseeds = numpy.array([True] * 2000)\nnonseeds[params[\"seeds\"]] = False\nnorm_thresh = params[\"thresholds\"] / degrees\n```\n\n(Communities encoded with colors)\n```{python}\nplt.figure()\nsns.scatterplot(\n    x = norm_thresh[:1000][nonseeds[:1000]],\n    y = result[:1000][nonseeds[:1000]])\nsns.scatterplot(\n    x = norm_thresh[1000:][nonseeds[1000:]],\n    y = result[1000:][nonseeds[1000:]])\nplt.xlabel(\"Threshold\")\nplt.ylabel(\"Average activation\")\nplt.show()\n\nplt.figure()\nhist(result[:1000][nonseeds[:1000]])\nhist(result[1000:][nonseeds[1000:]])\nplt.xlabel(\"Threshold\")\nplt.show()\n```"
  },
  {
    "objectID": "exp2.html",
    "href": "exp2.html",
    "title": "Experiment 2",
    "section": "",
    "text": "Same graph as experiment 1, but we now measure the “collateral” consequences in a few different ways.\n\nCode\nfrom exps import *\nimport numpy\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))])\n\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n\nWe generate a community graph, seeds, run the IC computation as before.\n\nCode\nic_result = run_experiment(params)\n\nBut now we collect our neighbor’s information first, and then compute the mean over that:\n\n\nCode\nimport matplotlib.pyplot as plt\n\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.mean(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n\n\n\n\n\nOr the min:\n\n\nCode\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(-1 if len(lst) == 0 else numpy.min(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 2\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nSame graph as [experiment 1](exp1.html), but we now measure the\n\"collateral\" consequences in a few different ways.\n\n```{python}\n#| code-fold: show\nfrom exps import *\nimport numpy\n\noverseeding_factor = 4\n\nparams = dict(\n    # graph params\n    n = 1000,\n    p1 = 0.01 / 2,\n    p2 = 0.01 / 2,\n    p_inter = 0.0001 / 2,\n    # seeding params\n    seed1 = overseeding_factor * 0.1,\n    seed2 = 0.1,\n    # IC params\n    alpha = 0.1,\n    reprs = 10000,\n    communities = [list(range(0, 1000)), list(range(1000, 2000))])\n\nparams[\"graph\"] = two_communities(params)\nparams[\"seeds\"] = set_seeds(params)\n```\n\nWe generate a community graph, seeds, run the IC computation as before.\n\n```{python}\nic_result = run_experiment(params)\n```\n\nBut now we collect our neighbor's information first, and then compute the mean over that:\n\n```{python}\nimport matplotlib.pyplot as plt\n\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(numpy.mean(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n```\n\nOr the min:\n\n```{python}\nic_neighbor_result = collect_neighbor_data(ic_result, params)\nic_neighbor_result = list(-1 if len(lst) == 0 else numpy.min(lst) for lst in ic_neighbor_result)\nplt.figure()\nplot_community_dists(ic_neighbor_result, params)\nplt.show()\n```"
  },
  {
    "objectID": "exp3.html",
    "href": "exp3.html",
    "title": "Experiment 3",
    "section": "",
    "text": "Two Erdos-Renyi graphs \\(n=1000, p=0.01\\) connected to one another with random edges, \\(p=0.0001\\). Same as before, but now we look at the overall probability conditioned on the community, and vary the overseeding.\n\nCode\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport json\n\ndef make_params(overseeding_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = overseeding_factor * 0.1,\n        seed2 = 0.1,\n        # IC params\n        alpha = 0.1,\n        reprs = 100,\n        communities = [list(range(0, 1000)), list(range(1000, 2000))]\n        )\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\nfactors = [1,2,3,4,5,6,7,8,9]\n\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Overseeding factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(f_mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(f_min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Experiment 3\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\nTwo Erdos-Renyi graphs $n=1000, p=0.01$ connected to one another with random edges, $p=0.0001$.\nSame as before, but now we look at the overall probability conditioned on the community, and\nvary the overseeding.\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\nimport json\n\ndef make_params(overseeding_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = overseeding_factor * 0.1,\n        seed2 = 0.1,\n        # IC params\n        alpha = 0.1,\n        reprs = 100,\n        communities = [list(range(0, 1000)), list(range(1000, 2000))]\n        )\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\nfactors = [1,2,3,4,5,6,7,8,9]\n\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Overseeding factor\")\n    plt.ylabel(label)\n    plt.show()\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(f_mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(f_min, \"min of neighbors' prob\")\n```"
  },
  {
    "objectID": "fig-4.html#sbm-isolated-communities",
    "href": "fig-4.html#sbm-isolated-communities",
    "title": "Figure 4, etc",
    "section": "SBM, Isolated Communities",
    "text": "SBM, Isolated Communities\n\n\nCode\nk = (5, graphs[0][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-1-sbm-isolated\")"
  },
  {
    "objectID": "fig-4.html#sbm-connected-communities",
    "href": "fig-4.html#sbm-connected-communities",
    "title": "Figure 4, etc",
    "section": "SBM, Connected Communities",
    "text": "SBM, Connected Communities\n\n\nCode\nk = (5, graphs[1][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-1-sbm-connected\")"
  },
  {
    "objectID": "fig-4.html#lfr-isolated-communities",
    "href": "fig-4.html#lfr-isolated-communities",
    "title": "Figure 4, etc",
    "section": "LFR, Isolated Communities",
    "text": "LFR, Isolated Communities\n\n\nCode\nk = (5, graphs[2][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-1-lfr-isolated\")"
  },
  {
    "objectID": "fig-4.html#lfr-connected-communities",
    "href": "fig-4.html#lfr-connected-communities",
    "title": "Figure 4, etc",
    "section": "LFR, Connected Communities",
    "text": "LFR, Connected Communities\n\n\nCode\nk = (5, graphs[3][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-1-lfr-connected\")"
  },
  {
    "objectID": "fig-4.html#sbm-isolated-communities-1",
    "href": "fig-4.html#sbm-isolated-communities-1",
    "title": "Figure 4, etc",
    "section": "SBM, Isolated Communities",
    "text": "SBM, Isolated Communities\n\n\nCode\nk = (5, graphs[0][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-2-sbm-isolated\")"
  },
  {
    "objectID": "fig-4.html#sbm-connected-communities-1",
    "href": "fig-4.html#sbm-connected-communities-1",
    "title": "Figure 4, etc",
    "section": "SBM, Connected Communities",
    "text": "SBM, Connected Communities\n\n\nCode\nk = (5, graphs[1][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-2-sbm-connected\")"
  },
  {
    "objectID": "fig-4.html#lfr-isolated-communities-1",
    "href": "fig-4.html#lfr-isolated-communities-1",
    "title": "Figure 4, etc",
    "section": "LFR, Isolated Communities",
    "text": "LFR, Isolated Communities\n\n\nCode\nk = (5, graphs[2][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-2-lfr-isolated\")"
  },
  {
    "objectID": "fig-4.html#lfr-connected-communities-1",
    "href": "fig-4.html#lfr-connected-communities-1",
    "title": "Figure 4, etc",
    "section": "LFR, Connected Communities",
    "text": "LFR, Connected Communities\n\n\nCode\nk = (5, graphs[3][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-2-lfr-connected\")"
  },
  {
    "objectID": "fig-4.html#sbm-isolated-communities-2",
    "href": "fig-4.html#sbm-isolated-communities-2",
    "title": "Figure 4, etc",
    "section": "SBM, Isolated Communities",
    "text": "SBM, Isolated Communities\n\n\nCode\nk = (5, graphs[0][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-1+2-sbm-isolated\")"
  },
  {
    "objectID": "fig-4.html#sbm-connected-communities-2",
    "href": "fig-4.html#sbm-connected-communities-2",
    "title": "Figure 4, etc",
    "section": "SBM, Connected Communities",
    "text": "SBM, Connected Communities\n\n\nCode\nk = (5, graphs[1][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-1+2-sbm-connected\")"
  },
  {
    "objectID": "fig-4.html#lfr-isolated-communities-2",
    "href": "fig-4.html#lfr-isolated-communities-2",
    "title": "Figure 4, etc",
    "section": "LFR, Isolated Communities",
    "text": "LFR, Isolated Communities\n\n\nCode\nk = (5, graphs[2][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-1+2-lfr-isolated\")"
  },
  {
    "objectID": "fig-4.html#lfr-connected-communities-2",
    "href": "fig-4.html#lfr-connected-communities-2",
    "title": "Figure 4, etc",
    "section": "LFR, Connected Communities",
    "text": "LFR, Connected Communities\n\n\nCode\nk = (5, graphs[3][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-1+2-lfr-connected\")"
  },
  {
    "objectID": "fig-4.html#sbm-isolated-communities-3",
    "href": "fig-4.html#sbm-isolated-communities-3",
    "title": "Figure 4, etc",
    "section": "SBM, Isolated Communities",
    "text": "SBM, Isolated Communities\n\n\nCode\nk = (5, graphs[0][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-3-1-sbm-isolated\")"
  },
  {
    "objectID": "fig-4.html#sbm-connected-communities-3",
    "href": "fig-4.html#sbm-connected-communities-3",
    "title": "Figure 4, etc",
    "section": "SBM, Connected Communities",
    "text": "SBM, Connected Communities\n\n\nCode\nk = (5, graphs[1][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-3-1-sbm-connected\")"
  },
  {
    "objectID": "fig-4.html#lfr-isolated-communities-3",
    "href": "fig-4.html#lfr-isolated-communities-3",
    "title": "Figure 4, etc",
    "section": "LFR, Isolated Communities",
    "text": "LFR, Isolated Communities\n\n\nCode\nk = (5, graphs[2][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-3-1-lfr-isolated\")"
  },
  {
    "objectID": "fig-4.html#lfr-connected-communities-3",
    "href": "fig-4.html#lfr-connected-communities-3",
    "title": "Figure 4, etc",
    "section": "LFR, Connected Communities",
    "text": "LFR, Connected Communities\n\n\nCode\nk = (5, graphs[3][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-3-1-lfr-connected\")"
  },
  {
    "objectID": "fig-4.html#sbm-isolated-communities-4",
    "href": "fig-4.html#sbm-isolated-communities-4",
    "title": "Figure 4, etc",
    "section": "SBM, Isolated Communities",
    "text": "SBM, Isolated Communities\n\n\nCode\nk = (5, graphs[0][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-3-2-sbm-isolated\")"
  },
  {
    "objectID": "fig-4.html#sbm-connected-communities-4",
    "href": "fig-4.html#sbm-connected-communities-4",
    "title": "Figure 4, etc",
    "section": "SBM, Connected Communities",
    "text": "SBM, Connected Communities\n\n\nCode\nk = (5, graphs[1][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-3-2-sbm-connected\")"
  },
  {
    "objectID": "fig-4.html#lfr-isolated-communities-4",
    "href": "fig-4.html#lfr-isolated-communities-4",
    "title": "Figure 4, etc",
    "section": "LFR, Isolated Communities",
    "text": "LFR, Isolated Communities\n\n\nCode\nk = (5, graphs[2][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-3-2-lfr-isolated\")"
  },
  {
    "objectID": "fig-4.html#lfr-connected-communities-4",
    "href": "fig-4.html#lfr-connected-communities-4",
    "title": "Figure 4, etc",
    "section": "LFR, Connected Communities",
    "text": "LFR, Connected Communities\n\n\nCode\nk = (5, graphs[3][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-3-2-lfr-connected\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Figure 4, etc\"\n---\n\nEach result \"row\" is based off:\n\n1. A set of graphs (realizations of a particular graph model)\n2. A one-parameter family of experiments\n\n# Preamble\n\n```{python}\nfrom exps import *\nimport copy\n\nn_reps = 100 # set this to 10000 when generating final results!\n\ndef run_experiment_batch(conf):\n    result = {}\n    for (k, params) in conf.items():\n        params = copy.copy(params)\n        params[\"ic_result\"] = run_experiment(params)\n        result[k] = params\n    return result\n\ndef run_thresh_experiment_batch(conf):\n    result = {}\n    for (k, params) in conf.items():\n        params = copy.copy(params)\n        degrees = numpy.array(list(len(n) for n in read_graph(params[\"graph\"])))\n        params[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\n        params[\"ic_result\"] = run_thresh_experiment(params)\n        result[k] = params\n    return result\n\ndef figure_1(params, xlabel):\n    c1, c2 = split_result_by_communities(params[\"ic_result\"], params)\n    hist(c1)\n    hist(c2)\n    plt.xlabel(xlabel)\n    plt.ylabel(\"Frequency\")\n\ndef figure_2(conf, ylabel):\n    x_values_1 = []\n    x_values_2 = []\n    y_values_1 = []\n    y_values_2 = []\n    for (k, v) in conf.items():\n        c1, c2 = split_result_by_communities(v[\"ic_result\"], v)\n        c1 = numpy.mean(c1)\n        c2 = numpy.mean(c2)\n        x_values_1.append(v[\"factor\"])\n        x_values_2.append(v[\"factor\"])\n        y_values_1.append(c1)\n        y_values_2.append(c2)\n    sns.lineplot(x = x_values_1, y = y_values_1, estimator = numpy.mean, ci = 95)\n    sns.lineplot(x = x_values_2, y = y_values_2, estimator = numpy.mean, ci = 95)\n    sns.scatterplot(x = x_values_1, y = y_values_1)\n    sns.scatterplot(x = x_values_2, y = y_values_2)\n    plt.xlabel(\"Factor\")\n    plt.ylabel(ylabel)\n\ndef figure_3(conf):\n    x_values = []\n    y_values = []\n    for (k, v) in conf.items():\n        c1, c2 = split_result_by_communities(v[\"ic_result\"], v)\n        c1 = numpy.mean(c1)\n        c2 = numpy.mean(c2)\n        f = min(c1, c2) / max(c1, c2)\n        x_values.append(v[\"factor\"])\n        y_values.append(f)\n    sns.lineplot(x = x_values, y = y_values, estimator = numpy.mean, ci = 95)\n    sns.scatterplot(x = x_values, y = y_values)\n    plt.ylim(0,1)\n    plt.xlabel(\"Factor\")\n    plt.ylabel(\"Fairness\")\n\ndef run_and_plot(conf, k, prefix):\n    r = run_experiment_batch(conf)\n    plt.figure()\n    figure_1(r[k], \"Access probability\")\n    plt.savefig(prefix + \"-fig-1.png\")\n    plt.show()\n    \n    plt.figure()\n    figure_2(r, \"Access\")\n    plt.savefig(prefix + \"-fig-2.png\")\n    plt.show()\n\n    plt.figure()\n    figure_3(r)\n    plt.savefig(prefix + \"-fig-3.png\")\n    plt.show()\n```\n\n# Experiment 1: Overseeding\n \n```{python}\ndef configure_experiment_1(factors, graphs):\n    result = {}\n    params = dict(\n        n1 = 1000,\n        n2 = 1000)\n    for f in factors:\n        for g in graphs:\n            # n = read_graph(g)\n            params[\"seed1\"] = f * 0.1\n            params[\"seed2\"] = 0.1 \n            params[\"graph\"] = g\n            params[\"seeds\"] = set_seeds(params)\n            params[\"factor\"] = f\n            params[\"graph_name\"] = g\n            params[\"alpha\"] = 0.1\n            params[\"reprs\"] = n_reps\n            params[\"communities\"] = [list(range(0, 1000)), list(range(1000, 2000))]\n            result[(f, g)] = copy.copy(params)\n    return result\n```\n\n## SBM, Isolated Communities\n\n```{python}\nk = (5, graphs[0][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-1-sbm-isolated\")\n```\n\n## SBM, Connected Communities\n\n```{python}\nk = (5, graphs[1][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-1-sbm-connected\")\n```\n\n## LFR, Isolated Communities\n\n```{python}\nk = (5, graphs[2][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-1-lfr-isolated\")\n```\n\n## LFR, Connected Communities\n\n```{python}\nk = (5, graphs[3][\"files\"][0])\nrun_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-1-lfr-connected\")\n```\n\n# Experiment 2: Deletions\n\n```{python}\nimport os\n\ndef delete_nodes_from_network(network, nodes_to_delete):\n    network = read_graph(network)\n    edge_list = graph_to_edge_list(network)\n    for n in nodes_to_delete:\n        network[n] = []\n    network = list(list(e for e in l if e not in nodes_to_delete)\n        for l in network)\n    n = temp_name(\".txt\")\n    write_graph(network, n)\n    return n\n\ndef configure_experiment_2(factors, graphs):\n    result = {}\n    params = dict(\n        n = 1000,\n        n1 = 1000,\n        n2 = 1000)\n    for f in factors:\n        for g in graphs:\n            # n = read_graph(g)\n            params[\"seed1\"] = 0.1\n            params[\"seed2\"] = 0.1\n            nodes_to_delete = set(set_seeds(dict(\n                n1 = 1000,\n                n2 = 1000,\n                seed1 = 0.1,\n                seed2 = 0.1 * f)))\n            params[\"nodes_to_delete\"] = nodes_to_delete\n            network = delete_nodes_from_network(g, nodes_to_delete)\n            params[\"graph\"] = network\n            params[\"seeds\"] = set_seeds(params)\n            params[\"factor\"] = f\n            params[\"graph_name\"] = g\n            params[\"alpha\"] = 0.1\n            params[\"reprs\"] = n_reps\n            params[\"communities\"] = [list(range(0, 1000)), list(range(1000, 2000))]\n            result[(f, g)] = copy.copy(params)\n    return result\n```\n\n## SBM, Isolated Communities\n\n```{python}\nk = (5, graphs[0][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-2-sbm-isolated\")\n```\n\n## SBM, Connected Communities\n\n```{python}\nk = (5, graphs[1][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-2-sbm-connected\")\n```\n\n## LFR, Isolated Communities\n\n```{python}\nk = (5, graphs[2][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-2-lfr-isolated\")\n```\n\n## LFR, Connected Communities\n\n```{python}\nk = (5, graphs[3][\"files\"][0])\nrun_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-2-lfr-connected\")\n```\n\n# Experiment 1+2: Overseeding and Deletions\n\n```{python}\nimport os\nimport random\n\ndef configure_experiment_1_and_2(factors, graphs):\n    conf = configure_experiment_1(factors, graphs)\n    r = run_experiment_batch(conf)\n    \n    result = {}\n    params = dict(\n        n = 1000,\n        n1 = 1000,\n        n2 = 1000)\n    for f in factors:\n        for g in graphs:\n            # n = read_graph(g)\n            params[\"seed1\"] = 0.3\n            params[\"seed2\"] = 0.3\n            \n            nodes_to_delete = set()\n            total_nodes = params[\"n1\"] + params[\"n2\"]\n            ic_result = r[(f, g)][\"ic_result\"]\n            for node in range(total_nodes):\n                if random.random() < ic_result[node]:\n                    nodes_to_delete.add(node)\n            \n            params[\"nodes_to_delete\"] = nodes_to_delete\n            network = delete_nodes_from_network(g, nodes_to_delete)\n            params[\"graph\"] = network\n            params[\"seeds\"] = set_seeds(params)\n            params[\"factor\"] = f\n            params[\"graph_name\"] = g\n            params[\"alpha\"] = 0.1\n            params[\"reprs\"] = n_reps\n            params[\"communities\"] = [list(range(0, 1000)), list(range(1000, 2000))]\n            result[(f, g)] = copy.copy(params)\n    return result\n```\n\n## SBM, Isolated Communities\n\n```{python}\nk = (5, graphs[0][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-1+2-sbm-isolated\")\n```\n\n## SBM, Connected Communities\n\n```{python}\nk = (5, graphs[1][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-1+2-sbm-connected\")\n```\n\n## LFR, Isolated Communities\n\n```{python}\nk = (5, graphs[2][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-1+2-lfr-isolated\")\n```\n\n## LFR, Connected Communities\n\n```{python}\nk = (5, graphs[3][\"files\"][0])\nrun_and_plot(configure_experiment_1_and_2(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-1+2-lfr-connected\")\n```\n\n# Experiment 3.1: Thresholds + Overseeding\n\n```{python}\ndef run_thresh_and_plot(conf, k, prefix):\n    r = run_thresh_experiment_batch(conf)\n    plt.figure()\n    figure_1(r[k], \"Activation probability\")\n    plt.savefig(prefix + \"-fig-1.png\")\n    plt.show()\n    \n    plt.figure()\n    figure_2(r, \"Activation\")\n    plt.savefig(prefix + \"-fig-2.png\")\n    plt.show()\n\n    plt.figure()\n    figure_3(r)\n    plt.savefig(prefix + \"-fig-3.png\")\n    plt.show()\n```\n\n## SBM, Isolated Communities\n\n```{python}\nk = (5, graphs[0][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-3-1-sbm-isolated\")\n```\n\n## SBM, Connected Communities\n\n```{python}\nk = (5, graphs[1][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-3-1-sbm-connected\")\n```\n\n## LFR, Isolated Communities\n\n```{python}\nk = (5, graphs[2][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-3-1-lfr-isolated\")\n```\n\n## LFR, Connected Communities\n\n```{python}\nk = (5, graphs[3][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_1(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-3-1-lfr-connected\")\n```\n\n# Experiment 3.2: Thresholds + Deletions\n\n## SBM, Isolated Communities\n\n```{python}\nk = (5, graphs[0][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[0][\"files\"]), k, \"figures/exp-3-2-sbm-isolated\")\n```\n\n## SBM, Connected Communities\n\n```{python}\nk = (5, graphs[1][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[1][\"files\"]), k, \"figures/exp-3-2-sbm-connected\")\n```\n\n## LFR, Isolated Communities\n\n```{python}\nk = (5, graphs[2][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[2][\"files\"]), k, \"figures/exp-3-2-lfr-isolated\")\n```\n\n## LFR, Connected Communities\n\n```{python}\nk = (5, graphs[3][\"files\"][0])\nrun_thresh_and_plot(configure_experiment_2(\n    list(range(1,10)),\n    graphs[3][\"files\"]), k, \"figures/exp-3-2-lfr-connected\")\n```"
  },
  {
    "objectID": "fig-5.html#data",
    "href": "fig-5.html#data",
    "title": "Essential Worker Community",
    "section": "Data",
    "text": "Data\n\nCode\nessential = []\nrest = []\nfiles = glob.glob(f'../data/graphs/experiment_essential_workers_2_sbm/run_1/twocommunities_edgelist.txt')\n# files = [ community_graph(0.0001/2, 1000, 0.015 / 2, 1000, 0.01 / 2) ]"
  },
  {
    "objectID": "fig-5.html#degree-distribution",
    "href": "fig-5.html#degree-distribution",
    "title": "Essential Worker Community",
    "section": "Degree distribution",
    "text": "Degree distribution\n\n\nCode\nfor f in files:\n    n = read_graph(f)\n    [this_essential, this_rest] = get_community_degrees(n, {\"n1\": 1000, \"n2\": 1000})\n    essential.extend(this_essential)\n    rest.extend(this_rest)\nplot_community_degrees(\n    [essential, rest],\n    [\"Essential worker community\", \"Rest\"], \n    filename=\"figures/essential-worker-sbm-degree-distribution.png\",\n    range=(0, 27))"
  },
  {
    "objectID": "fig-5.html#section",
    "href": "fig-5.html#section",
    "title": "Essential Worker Community",
    "section": "1",
    "text": "1\n\n\nCode\nparams = {}\ndegrees = numpy.array(list(len(n) for n in read_graph(files[0])))\nparams[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\nnodes_to_delete = set(set_seeds(dict(\n                n1 = 1000,\n                n2 = 1000,\n                seed1 = 0.1,\n                seed2 = 0.1)))\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, files[0])\nparams[\"n1\"] = 1000\nparams[\"n2\"] = 1000\nparams[\"seed1\"] = 0.1\nparams[\"seed2\"] = 0.1\nparams[\"seeds\"] = set_seeds(params)\nparams[\"alpha\"] = 0.1\nparams[\"reprs\"] = 100\nparams[\"communities\"] = [list(range(0, 1000)), list(range(1000, 2000))]\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.5526528117359413, 0.2842606516290727"
  },
  {
    "objectID": "fig-5.html#section-1",
    "href": "fig-5.html#section-1",
    "title": "Essential Worker Community",
    "section": "2",
    "text": "2\n\n\nCode\nparams[\"ic_result\"] = run_thresh_experiment(params)\n\nplt.figure()\nfigure_1(params, \"collateral harm\")\nplt.show()\n\n\nCommunity means: 0.5494987775061125, 0.3284586466165414"
  },
  {
    "objectID": "fig-5.html#a-sbm-based",
    "href": "fig-5.html#a-sbm-based",
    "title": "Essential Worker Community",
    "section": "3a, SBM-based",
    "text": "3a, SBM-based\n\n\nCode\nparams = {}\nparams[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\nnodes_to_delete = set(set_seeds(dict(\n                n1 = 1000,\n                n2 = 1000,\n                seed1 = 0.12,\n                seed2 = 0.08)))\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, files[0])\nparams[\"n1\"] = 1000\nparams[\"n2\"] = 1000\nparams[\"seed1\"] = 0.1\nparams[\"seed2\"] = 0.1\nparams[\"seeds\"] = set_seeds(params)\nparams[\"alpha\"] = 0.1\nparams[\"reprs\"] = 100\nparams[\"communities\"] = [list(range(0, 1000)), list(range(1000, 2000))]\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.5394444444444445, 0.27281472684085517"
  },
  {
    "objectID": "fig-5.html#b-degree-based",
    "href": "fig-5.html#b-degree-based",
    "title": "Essential Worker Community",
    "section": "3b, degree-based",
    "text": "3b, degree-based\n\n\nCode\nprobs = numpy.array(degrees)\nprobs = (probs / probs.sum()) * 200.0\nnodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, files[0])\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.5075322997416021, 0.2687529976019185"
  },
  {
    "objectID": "fig-5.html#c-probability-based",
    "href": "fig-5.html#c-probability-based",
    "title": "Essential Worker Community",
    "section": "3c, probability-based",
    "text": "3c, probability-based\n\n\nCode\nprobs = numpy.array(degrees)\nprobs = 1 - numpy.power(1 - params[\"alpha\"], degrees)\nprobs = (probs / probs.sum()) * 200.0\nnodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, files[0])\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.5335884567126725, 0.25520446096654276"
  },
  {
    "objectID": "fig-5.html#section-2",
    "href": "fig-5.html#section-2",
    "title": "Essential Worker Community",
    "section": "4",
    "text": "4\n\n\nCode\nparams[\"ic_result\"] = run_thresh_experiment(params)\n\nplt.figure()\nfigure_1(params, \"collateral harm\")\nplt.show()\n\n\nCommunity means: 0.5027478042659975, 0.28784386617100377"
  },
  {
    "objectID": "fig-5.html#data-1",
    "href": "fig-5.html#data-1",
    "title": "Essential Worker Community",
    "section": "Data",
    "text": "Data\n\nCode\nn_communities = 5\ndef get_n1():\n    return int(2000 / n_communities)\nn1 = get_n1()\nn2 = 2000 - n1\nparams = {}\nparams[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\nparams[\"n1\"] = n1\nparams[\"n2\"] = n2\n\ndef make_many_community_graph():\n    params = [0.0001/2, n1, (0.015 / 2) / (n1 / 1000)]\n    for i in range(n_communities - 1):\n        params.extend([n1, (0.01 / 2) / (n1 / 1000)])\n    return community_graph(*params)\n\nmany_comms = make_many_community_graph()"
  },
  {
    "objectID": "fig-5.html#degree-distribution-1",
    "href": "fig-5.html#degree-distribution-1",
    "title": "Essential Worker Community",
    "section": "Degree distribution",
    "text": "Degree distribution\n\n\nCode\nplot_community_degrees(\n    get_community_degrees(read_graph(many_comms), params),\n    [\"Essential worker community\", \"Rest\"], range=(0, 27))"
  },
  {
    "objectID": "fig-5.html#section-3",
    "href": "fig-5.html#section-3",
    "title": "Essential Worker Community",
    "section": "1",
    "text": "1\n\n\nCode\nnodes_to_delete = set(set_seeds(dict(\n                n1 = n1,\n                n2 = n2,\n                seed1 = 0.1,\n                seed2 = 0.1)))\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, many_comms)\nparams[\"seed1\"] = 0.1\nparams[\"seed2\"] = 0.1\nparams[\"seeds\"] = set_seeds(params)\nparams[\"alpha\"] = 0.1\nparams[\"reprs\"] = 100\nparams[\"communities\"] = [list(range(0, n1)), list(range(n1, 2000))]\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.548006230529595, 0.2702731411229135"
  },
  {
    "objectID": "fig-5.html#section-4",
    "href": "fig-5.html#section-4",
    "title": "Essential Worker Community",
    "section": "2",
    "text": "2\n\n\nCode\nparams[\"ic_result\"] = run_thresh_experiment(params)\n\nplt.figure()\nfigure_1(params, \"collateral harm\")\nplt.show()\n\n\nCommunity means: 0.5640498442367601, 0.2938543247344461"
  },
  {
    "objectID": "fig-5.html#a-sbm-based-1",
    "href": "fig-5.html#a-sbm-based-1",
    "title": "Essential Worker Community",
    "section": "3a, SBM-based",
    "text": "3a, SBM-based\nThis is not exactly comparable because since the overall sizes changed, there are now fewer essential workers, so to make vaccination rate difference match the degree difference, we need to change the parameters.\nGiven some amount of overseeding, community size, and total budget, we can work out the seeding probabilities.\n\n\nCode\ndef solve_seeding(n1, overseeding = 1.5):\n    budget = 200\n    size = 2000\n    n2 = size - n1\n    return budget / (size + (overseeding - 1) * n1)\n\ndef plot_overseeding(overseeding):\n    params = {}\n    params[\"thresholds\"] = numpy.random.random(len(degrees)) * degrees\n    nodes_to_delete = set(set_seeds(dict(\n                n1 = n1,\n                n2 = n2,\n                seed1 = solve_seeding(n1, overseeding) * overseeding,\n                seed2 = solve_seeding(n1, overseeding))))\n    params[\"nodes_to_delete\"] = nodes_to_delete\n    set_graph(params, many_comms)\n    params[\"n1\"] = n1\n    params[\"n2\"] = n2\n    params[\"seed1\"] = 0.1\n    params[\"seed2\"] = 0.1\n    params[\"seeds\"] = set_seeds(params)\n    params[\"alpha\"] = 0.1\n    params[\"reprs\"] = 100\n    params[\"communities\"] = [list(range(0, n1)), list(range(n1, 2000))]\n    params[\"ic_result\"] = run_experiment(params)\n    plt.figure()\n    figure_1(params, \"probability of infection, overseeding = %s\" % overseeding)\n    plt.show()\n    params[\"ic_result\"] = run_thresh_experiment(params)\n    plt.figure()\n    figure_1(params, \"collateral harm, overseeding = %s\" % overseeding)\n    plt.show()\n\nplot_overseeding(1)\nplot_overseeding(10)\n\n\nCommunity means: 0.5308282208588957, 0.2727700617283951\n\n\n\n\n\nCommunity means: 0.5205828220858895, 0.3099074074074074\n\n\n\n\n\nCommunity means: 0.3237931034482759, 0.3124025974025974\n\n\n\n\n\nCommunity means: 0.2965948275862069, 0.3757070707070707"
  },
  {
    "objectID": "fig-5.html#b-degree-based-1",
    "href": "fig-5.html#b-degree-based-1",
    "title": "Essential Worker Community",
    "section": "3b, degree-based",
    "text": "3b, degree-based\n\n\nCode\nprobs = numpy.array(degrees)\nprobs = (probs / probs.sum()) * 200.0\nnodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, many_comms)\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.5310759493670886, 0.2661497730711044"
  },
  {
    "objectID": "fig-5.html#c-probability-based-1",
    "href": "fig-5.html#c-probability-based-1",
    "title": "Essential Worker Community",
    "section": "3c, probability-based",
    "text": "3c, probability-based\n\n\nCode\nprobs = numpy.array(degrees)\nprobs = 1 - numpy.power(1 - params[\"alpha\"], degrees)\nprobs = (probs / probs.sum()) * 200.0\nnodes_to_delete = set(i for (i, v) in enumerate(list(probs)) if random.random() < v)\nparams[\"nodes_to_delete\"] = nodes_to_delete\nset_graph(params, many_comms)\nparams[\"ic_result\"] = run_experiment(params)\n\nplt.figure()\nfigure_1(params, \"probability of infection\")\nplt.show()\n\n\nCommunity means: 0.5237223974763406, 0.24987786259541986"
  },
  {
    "objectID": "fig-5.html#section-5",
    "href": "fig-5.html#section-5",
    "title": "Essential Worker Community",
    "section": "4",
    "text": "4\n\n\nCode\nparams[\"ic_result\"] = run_thresh_experiment(params)\n    \nplt.figure()\nfigure_1(params, \"collateral harm\")\nplt.show()\n\n\nCommunity means: 0.5697160883280757, 0.2709007633587786"
  },
  {
    "objectID": "exp4.html",
    "href": "exp4.html",
    "title": "",
    "section": "",
    "text": "Community-wide impact of network modifications\n(This is Section 5.3)\nSame as experiment 3, but we range the community shrinkage from 0.1 to 0.9.\n\nCode\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        params[\"communities\"] = [list(range(0, n1)), list(range(n1, n1 + n2))]\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\nNo transformation:\n\n\nCode\nplot_curve(id, \"prob\")\n\n\n\n\n\nSquare:\n\n\nCode\nplot_curve(square, \"squared prob\")\n\n\n\n\n\nMean of neighbors:\n\n\nCode\nplot_curve(f_mean, \"mean of neighbors' prob\")\n\n\n\n\n\nMin of neighbors:\n\n\nCode\nplot_curve(f_min, \"min of neighbors' prob\")\n\n\n\n\n\n\n\n\nSource Code\n---\nTitle: \"Experiment 4\"\nformat: \n  html:\n    code-tools: true\n    code-fold: true\n---\n\n# Community-wide impact of network modifications\n\n(This is Section 5.3)\n\nSame as [experiment 3](exp3.qmd), but we range the community shrinkage from 0.1 to 0.9.\n\n```{python}\nfrom exps import *\nimport numpy\nimport matplotlib.pyplot as plt\n\ndef make_params(shrink_factor):\n    return dict(\n        # graph params\n        n = 1000,\n        p1 = 0.01 / 2,\n        p2 = 0.01 / 2,\n        p_inter = 0.0001 / 2,\n        # seeding params\n        seed1 = 0.3,\n        seed2 = 0.3,\n        # IC params\n        alpha = 0.1,\n        reprs = 100)\n\ndef run_experiment_range(factors, f):\n    c1s = []\n    c2s = []\n    for factor in factors:\n        params = make_params(factor)\n        n1 = int(params[\"n\"] * (1 - factor))\n        n2 = int(params[\"n\"] * (1 - 0.1))\n        params[\"n1\"] = n1\n        params[\"n2\"] = n2\n        params[\"communities\"] = [list(range(0, n1)), list(range(n1, n1 + n2))]\n        params[\"graph\"] = two_communities(params)\n        params[\"seeds\"] = set_seeds(params)\n        ic_result = run_experiment(params)\n        ic_result = f(ic_result, params)\n        c1, c2 = split_result_by_communities(ic_result, params)\n        c1s.append(numpy.mean(c1))\n        c2s.append(numpy.mean(c2))\n    return c1s, c2s\n\nfactors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\ndef plot_curve(f, label):\n    c1s, c2s = run_experiment_range(factors, f)\n    plt.figure()\n    plt.plot(factors, c1s)\n    plt.plot(factors, c2s)\n    plt.xlabel(\"Shrinkage factor\")\n    plt.ylabel(label)\n    plt.show()\n\n```\n\nNo transformation:\n\n```{python}\nplot_curve(id, \"prob\")\n```\n\nSquare:\n\n```{python}\nplot_curve(square, \"squared prob\")\n```\n\nMean of neighbors:\n\n```{python}\nplot_curve(f_mean, \"mean of neighbors' prob\")\n```\n\nMin of neighbors:\n\n```{python}\nplot_curve(f_min, \"min of neighbors' prob\")\n```"
  }
]